<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Unleashing the Secrets Behind EasyAntiCheat’s CR3 Protection :: AVX&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Unleashing the Secrets of EasyAntiCheat&#39;s CR3 Protection: A Comprehensive Analysis and Bypass Guide." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/posts/easyanticheat-cr3-protection/" />






  
  
  
  
  
  <link rel="stylesheet" href="/styles.css">







  <link rel="shortcut icon" href="/img/theme-colors/pink.png">
  <link rel="apple-touch-icon" href="/img/theme-colors/pink.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="AVX" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Unleashing the Secrets Behind EasyAntiCheat’s CR3 Protection">
<meta property="og:description" content="Unleashing the Secrets of EasyAntiCheat&#39;s CR3 Protection: A Comprehensive Analysis and Bypass Guide." />
<meta property="og:url" content="/posts/easyanticheat-cr3-protection/" />
<meta property="og:site_name" content="AVX&#39;s Blog" />

  
    <meta property="og:image" content="/img/favicon/pink.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2023-04-13 00:00:00 &#43;0000 UTC" />












</head>
<body class="pink">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    AVX&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/posts/easyanticheat-cr3-protection/">Unleashing the Secrets Behind EasyAntiCheat’s CR3 Protection</a>
  </h1>
  <div class="post-meta">
    
      <time class="post-date">
        2023-04-13 ::
        
      </time>
    
    
      <span class="post-author">AVX</span>
    
    
  </div>

  
  


  

  <div class="post-content"><div>
        <h1 id="disclaimer">Disclaimer<a href="#disclaimer" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>The information provided in this document is intended <strong>solely for educational and informational purposes</strong>. It is <strong>not meant to belittle EasyAntiCheat</strong> or any individuals involved in its development or implementation. Rather, it aims to shed light on the internal workings of EasyAntiCheat so that consumers can better understand what happens behind the scenes when playing their favorite games. Any opinions expressed herein <strong>do not necessarily reflect those of EasyAntiCheat</strong> or any other parties mentioned. This document is provided &ldquo;<strong>as is</strong>&rdquo; without warranty of any kind, either express or implied, including but not limited to the implied warranties of merchantability and fitness for a particular purpose. I shall not be liable for any damages whatsoever arising out of or in connection with the use of this document.</p>
<h1 id="introduction">Introduction<a href="#introduction" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>The world of online gaming has long been plagued by the scourge of cheaters, whose insidious machinations threaten to undermine the very foundations upon which fair play and competition are built. But fear not, for there is a shining beacon of hope in this dark and murky landscape - EasyAntiCheat. Employed by some of the most popular titles on the market today, this cutting-edge software represents a formidable bulwark against those who would seek to gain an unfair advantage through illicit means. But just how does it work? What makes it so effective? And can it truly stand up to the ever-evolving tactics of the cheating underworld? Join us as we delve deep into the heart of this technological marvel and uncover the secrets that make it a force to be reckoned with.</p>
<h1 id="before-we-dive-in-getting-the-basics-right">Before We Dive In: Getting the Basics Right<a href="#before-we-dive-in-getting-the-basics-right" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>To proceed with the remaining part of the article, I recommend first addressing these topics:</p>
<ul>
<li><a href="https://www.triplefault.io/2017/07/introduction-to-ia-32e-hardware-paging.html">IA-32e Hardware Paging</a></li>
<li><a href="https://www.triplefault.io/2017/08/exploring-windows-virtual-memory.html">Windows Virtual Memory Management</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_isolation">Process Isolation</a></li>
</ul>
<h1 id="identifying-the-problem">Identifying the Problem<a href="#identifying-the-problem" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>As any individual who has engaged in cheating will attest, accessing memory is a pivotal aspect of the process. However, with anti-cheat measures operating at the kernel level, cheaters have had to resort to executing at this elevated level as well; the highest level under <code>SMM</code> and <code>VT-X/AMD-V</code>.</p>
<p>As anti-cheats have evolved, they have adopted increasingly sophisticated strategies that delve deep into the intricacies of the Windows kernel. Take, for instance, Vanguard, the anti-cheat system used in Valorant. It safeguards critical game regions by utilizing a technique to hook context swaps and creating a whitelist of specific threads that are authorized to access their cloned <code>CR3</code>; which allows for seamless, yet secure, access to the protected memory.</p>
<p>Such measures have proven especially effective in thwarting DMA cheats, which leverage an external device to translate virtual memory to its corresponding physical memory mappings and extract data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>VOID VgkHooks<span style="color:#f92672">::</span>PostSwapContext( PVOID Thread )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	UINT64 ThreadIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	BOOLEAN AllowCr3Write <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// I have simplified it here, this routine actually decrypts the obfuscated import.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> PsGetThreadProcess <span style="color:#f92672">=</span> Vgk<span style="color:#f92672">::</span>Imports<span style="color:#f92672">::</span>PsGetThreadProcess;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Ensure that we are swapping a thread associated with Valorant.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( __readcr3( ) <span style="color:#f92672">==</span> GuardedRegion.GameCr3 )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( PsGetThreadProcess( Thread ) <span style="color:#f92672">==</span> VgkData<span style="color:#f92672">::</span>ValorantProcess )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			_disable( );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// Update the pml4s, Windows may have changed it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			Vgk<span style="color:#f92672">::</span>Setup( GuardedRegion.OriginalPml4s );
</span></span><span style="display:flex;"><span>			memcpy( GuardedRegion.ClonedPml4s, GuardedRegion.OriginalPml4s, PAGE_SIZE );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// As the pml4 table has been overwritten, it is necessary for us to reset our pml4e.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			GuardedRegion.ClonedPml4s[ GuardedRegion.AvailablePml4Index ] <span style="color:#f92672">=</span> GuardedRegion.NewPml4e;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// Has the game surpassed the maximum allowable whitelisted thread count as permitted by VGK?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> ( ThreadData.Count <span style="color:#f92672">!=</span> VGK_MAX_THREADS )
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>ThreadData.Count )
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>				WriteCr3:
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> ( AllowCr3Write )
</span></span><span style="display:flex;"><span>						__writecr3( GuardedRegion.NewCr3 );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> ( ShouldFlushTlb )
</span></span><span style="display:flex;"><span>						FlushTlb( );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>					_enable( );
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#75715e">// If not, enumerate through each whitelisted thread.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">while</span> ( Thread <span style="color:#f92672">!=</span> ThreadData.List[ ThreadIndex ] )
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> ( ThreadIndex<span style="color:#f92672">++</span> <span style="color:#f92672">&gt;=</span> ThreadData.Count )
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">goto</span> WriteCr3;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			AllowWriteCr3 <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> WriteCr3;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span> 	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>The code that is not relevant to this article has been redacted, and the remaining code has been formatted for improved readability.</p>
</blockquote>
<p>While this is certainly fascinating, the question remains: how does all of this relate to EasyAntiCheat? As it turns out, EasyAntiCheat is also quite adept at detecting and thwarting cheat attempts. In fact, it employs a technique that is similar to the aforementioned Vanguard anti-cheat, albeit one that is more complex in nature.</p>
<p>However, unlike Vanguard, which utilizes two legitimate address spaces, EasyAntiCheat opts for a different approach - one that involves concealing its original <code>CR3</code> from any prying eyes. This is an involved and intricate technique, but one that has proven to be quite effective in deterring cheaters.</p>
<blockquote>
<p>It&rsquo;s worth noting that <code>Rust</code>, the game detailed in this article, incorporates <code>EasyAntiCheat_EOS</code>. As far as my observation goes, no other EOS-protected game has implemented this particular approach.</p>
</blockquote>
<h1 id="explaining-the-problem">Explaining the Problem<a href="#explaining-the-problem" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>In order to provide additional support for the claims we have made, we&rsquo;ll translate Rust&rsquo;s base address to its corresponding physical mapping using the <code>CR3</code> located in the <code>EProcess::DirectoryTableBase</code> field. This will provide us with concrete evidence to support our claim, which is a critical step because if the <code>CR3</code> value is truly invalid, the translation process would fail as it would not be pointing to any legitimate <code>PML4</code> table.</p>
<p>To further validate our findings, we&rsquo;ll compare the results obtained through this process with the actual game&rsquo;s fixed <code>CR3</code>.</p>
<p>To simplify this task, and make the process more efficient, we&rsquo;ll utilize the well-known and widely-used <a href="https://www.cheatengine.org/">Cheat Engine</a> Lua scripting interface.</p>
<blockquote>
<p>I decided to use Cheat Engine because it offers scripting capabilities that can be quickly accessed and modified, rather than having to create a driver for every minor alteration.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> RustProcess <span style="color:#f92672">=</span> dbk_getPEProcess( RustPid );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> RustSectionBaseAddress <span style="color:#f92672">=</span> readQword( RustProcess <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x520</span> );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> RustDirectoryTableBase <span style="color:#f92672">=</span> readQword( RustProcess <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x28</span> );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print( string.format( <span style="color:#e6db74">&#34;RustSectionBaseAddress -&gt; %X&#34;</span>, RustSectionBaseAddress ) );
</span></span><span style="display:flex;"><span>print( string.format( <span style="color:#e6db74">&#34;RustDirectoryTableBase -&gt; %X&#34;</span>, RustDirectoryTableBase ) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> RustPhysicalBaseAddress <span style="color:#f92672">=</span> getPhysicalAddressCR3( RustDirectoryTableBase, RustSectionBaseAddress );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> RustPhysicalBaseAddress <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  	print( <span style="color:#e6db74">&#34;Error -&gt; 0&#34;</span> );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>   	print( string.format( <span style="color:#e6db74">&#34;Success -&gt; %X&#34;</span>, RustPhysicalBaseAddress ) );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">--[[
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	RustSectionBaseAddress -&gt; 7FF7B4600000 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	RustDirectoryTableBase -&gt; 4000000853DFF000 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	Error -&gt; 0 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--]]</span>
</span></span></code></pre></div><p>Now, for the corresponding counterpart:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> RustProcess <span style="color:#f92672">=</span> dbk_getPEProcess( RustPid );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> RustSectionBaseAddress <span style="color:#f92672">=</span> readQword( RustProcess <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x520</span> );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> RustDirectoryTableBase <span style="color:#f92672">=</span> dbk_getCR3( );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print( string.format( <span style="color:#e6db74">&#34;RustSectionBaseAddress -&gt; %X&#34;</span>, RustSectionBaseAddress ) );
</span></span><span style="display:flex;"><span>print( string.format( <span style="color:#e6db74">&#34;RustDirectoryTableBase -&gt; %X&#34;</span>, RustDirectoryTableBase ) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> RustPhysicalBaseAddress <span style="color:#f92672">=</span> getPhysicalAddressCR3( RustDirectoryTableBase, RustSectionBaseAddress );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> RustPhysicalBaseAddress <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  	print( <span style="color:#e6db74">&#34;Error -&gt; 0&#34;</span> );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>   	print( string.format( <span style="color:#e6db74">&#34;Success -&gt; %X&#34;</span>, RustPhysicalBaseAddress ) );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">--[[
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	RustSectionBaseAddress -&gt; 7FF7B4600000 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	RustDirectoryTableBase -&gt; 197198000 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	Success -&gt; 199CFE000 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--]]</span>
</span></span></code></pre></div><p>As you can see, the <code>CR3</code> value <code>4000000853DFF000</code> appears quite peculiar at first glance. It&rsquo;s pretty obvious that something is amiss even before consulting the manual. To get a better understanding, let&rsquo;s use the programmer&rsquo;s calculator on Windows to examine the toggled bits in the 64-bit integer.</p>
<p><img src="https://i.imgur.com/nzYfRgr.png" alt=""></p>
<p>As observed from the calculator&rsquo;s output, the 63rd bit is set. Armed with this knowledge, we can now refer to the manual to determine if this is a reserved bit that would trigger any sort of exception.</p>
<ul>
<li>If an attempt is made to change <code>CR4.PCIDE</code> from 0 to 1 while <code>CR3[11:0]</code> ≠ <code>000H</code>.</li>
<li>If an attempt is made to clear <code>CR0.PG[bit 31]</code>.</li>
<li>If an attempt is made to write a 1 to any reserved bit in <code>CR4</code>.</li>
<li>If an attempt is made to write a 1 to any reserved bit in <code>CR8</code>.</li>
<li>If an attempt is made to write a 1 to any reserved bit in <code>CR3[63:MAXPHYADDR]</code>.</li>
<li>If an attempt is made to leave IA-32e mode by clearing <code>CR4.PAE[bit 5]</code>.</li>
</ul>
<p>Since our focus is on a particular control register, namely the third one, we can narrow down the scope of the search to indicate that triggering a <code>#GP(0)</code> exception would occur only if one tries to write a value of 1 to any reserved bit within <code>CR3[63:MAXPHYADDR]</code>, which is exactly what we&rsquo;re looking for!</p>
<p>At this point, you might be wondering why it&rsquo;s not possible to unset those bits to make the <code>CR3</code> valid. However, the <code>CR3</code> that&rsquo;s saved within Rust&rsquo;s process is solely intended to trigger an exception and doesn&rsquo;t refer to any <code>PML4s</code> (without proper decryption). This approach from EasyAntiCheat is quite clever as it compels reverse engineers, such as ourselves, to reverse their driver.</p>
<h1 id="connecting-the-dots-the-thread-scheduler">Connecting the Dots: The Thread Scheduler<a href="#connecting-the-dots-the-thread-scheduler" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Now that we have obtained the prerequisite knowledge on the issue at hand, we can start connecting the dots to understand how EasyAntiCheat is exploiting the vulnerability.</p>
<p>As we already know, EasyAntiCheat forces an exception when the <code>EProcess::DirectoryTableBase</code> is being written to the <code>CR3</code> of any active processor. However, this raises the question: how exactly are they are abusing this?</p>
<p>To answer this question, let&rsquo;s take a closer look at the <code>ntoskrnl!SwapContext</code> routine, which is responsible for swapping the current core&rsquo;s context to a new thread.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The impact of their hook extends beyond this specific routine and encompasses any kernel routine that involves CR3 swapping, such as KiAttachProcess.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>UINT64 ProcessCr3 <span style="color:#f92672">=</span> Process<span style="color:#f92672">-&gt;</span>DirectoryTableBase;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( ( HvlEnlightenments <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// If HyperV is present, it&#39;ll handle swapping the current core&#39;s CR3.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	HvlSwitchVirtualAddressSpace( ProcessCr3 );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	__writecr3( ProcessCr3 );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( ShouldFlushTlb )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// If possible, flushes the TLB for the current core. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">auto</span> Cr4 <span style="color:#f92672">=</span> __readcr4( );
</span></span><span style="display:flex;"><span>  		Cr4 <span style="color:#f92672">^=</span> <span style="color:#ae81ff">0x80</span>;
</span></span><span style="display:flex;"><span>		__writecr4( Cr4 );
</span></span><span style="display:flex;"><span>		__writecr4( Cr4 <span style="color:#f92672">^</span> <span style="color:#ae81ff">0x80</span> );
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>The code that is not relevant to this article has been redacted, and the remaining code has been formatted for improved readability.</p>
</blockquote>
<p>By analyzing the code within this routine, we can see that the function proceeds to update the <code>CR3</code> register to the <code>EProcess::DirectoryTableBase</code> field using the <code>__writecr3</code> intrinsic.
It is at this point where EasyAntiCheat is able to exploit the vulnerability. By forcing an exception, and catching it, EasyAntiCheat is able to instrument when a thread is being swapped, and thereby obtain complete and utter control over their game&rsquo;s context-switches (and other whitelisted regions).</p>
<h1 id="connecting-the-dots-wresling-the-exception">Connecting the Dots: Wresling the Exception<a href="#connecting-the-dots-wresling-the-exception" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Following the reverse engineering process, the next step is to locate the location where EasyAntiCheat writes the updated <code>CR3</code>. Based on our previous findings, this will be found within their exception hook.</p>
<p>Although there are multiple methods to achieve this, the steps I will take include:</p>
<ul>
<li>Utilizing my <code>VT-X</code> hypervisor to virtualize all logical processors.</li>
<li>Installing an image load callback.</li>
<li>Upon the loading of the <code>EasyAntiCheat_EOS.sys</code> driver, preserving the driver&rsquo;s details.</li>
<li>Deferring a task to the subsequent <code>CR3</code> write, if an attempt is made to write a 1 to any reserved bit in <code>CR3[63:MAXPHYADDR]</code>.</li>
<li>Recording the <code>RVA</code> using EasyAntiCheat&rsquo;s stored driver information.</li>
</ul>
<p>Upon completion of the aforementioned steps, and removing duplicates for clarity, the outcomes obtained are:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{<span style="color:#f92672">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;Invalid&#34;</span>,<span style="color:#f92672">&#34;RVA&#34;</span>:<span style="color:#e6db74">&#34;ntoskrnl.exe+0x40028F&#34;</span>}
</span></span><span style="display:flex;"><span>{<span style="color:#f92672">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;Valid&#34;</span>,<span style="color:#f92672">&#34;RVA&#34;</span>:<span style="color:#e6db74">&#34;EasyAntiCheat_EOS.sys+0x19A20&#34;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{<span style="color:#f92672">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;Invalid&#34;</span>,<span style="color:#f92672">&#34;RVA&#34;</span>:<span style="color:#e6db74">&#34;ntoskrnl.exe+0x20C130&#34;</span>}
</span></span><span style="display:flex;"><span>{<span style="color:#f92672">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;Valid&#34;</span>,<span style="color:#f92672">&#34;RVA&#34;</span>:<span style="color:#e6db74">&#34;EasyAntiCheat_EOS.sys+0x19A20&#34;</span>}
</span></span></code></pre></div><p>Although it may appear daunting initially, it is not something we have not previously discussed. Let&rsquo;s review it together.</p>
<p>First, let us direct our attention towards the <code>Invalid</code> outcomes, which occur when the kernel writes EasyAntiCheat&rsquo;s exception-forced <code>CR3</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>.text:<span style="color:#960050;background-color:#1e0010">000000000040028</span><span style="color:#a6e22e">F</span>      <span style="color:#ae81ff">0</span><span style="color:#66d9ef">F</span> <span style="color:#ae81ff">22</span> <span style="color:#66d9ef">D9</span>      <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">cr3</span>, <span style="color:#66d9ef">rcx</span> <span style="color:#75715e">; SwapContext
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>.text:<span style="color:#960050;background-color:#1e0010">000000000020</span><span style="color:#a6e22e">C130</span>      <span style="color:#ae81ff">0</span><span style="color:#66d9ef">F</span> <span style="color:#ae81ff">22</span> <span style="color:#66d9ef">DF</span>      <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">cr3</span>, <span style="color:#66d9ef">rdi</span> <span style="color:#75715e">; KiAttachProcess
</span></span></span></code></pre></div><p>As you can observe, we have previously covered this, it&rsquo;s where the kernel writes Rust&rsquo;s <code>CR3</code>. Let&rsquo;s now shift our focus towards the juicy <code>Valid</code> outcomes, where EasyAntiCheat writes the genuine <code>CR3</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOLEAN EacHooks<span style="color:#f92672">::</span>HandleException( ExceptonData<span style="color:#f92672">*</span> Exception, PCONTEXT Context )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define GetFixedCr3( Key ) ((__ROR8__(_byteswap_uint64(Key), 31) &amp; 0xFFFFFFFFF) &lt;&lt; 12)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( Exception<span style="color:#f92672">-&gt;</span>Code <span style="color:#f92672">==</span> STATUS_PRIVILEGED_INSTRUCTION  )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// --&gt; &#34;mov cr3&#34;, ??
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>( WORD<span style="color:#f92672">*</span> )Context<span style="color:#f92672">-&gt;</span>Rip <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x220F</span> )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// mov cr3, &#34;??&#34; &lt;--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			BYTE Operand <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>( BYTE<span style="color:#f92672">*</span> )( Context<span style="color:#f92672">-&gt;</span>Rip <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// Converts the operand to an offset in the context structure, beginning from RAX.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			Operand <span style="color:#f92672">&amp;=</span> <span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// Retrieve the CR3 that was being written from its register.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			UINT64<span style="color:#f92672">*</span> Registers <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>Context<span style="color:#f92672">-&gt;</span>Rax;
</span></span><span style="display:flex;"><span>			UINT64 AttemptedCr3 <span style="color:#f92672">=</span> Registers[ Operand ];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// This is always computes to the same value, which is the base of their structure&#39;s allocation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			UINT64 DataOffset <span style="color:#f92672">=</span> InterlockedExchangeAdd64( EAC<span style="color:#f92672">::</span>InitialDataOffset, <span style="color:#ae81ff">0x1000000000</span> );
</span></span><span style="display:flex;"><span>			DataOffset <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0x1000000000</span>;
</span></span><span style="display:flex;"><span>			DataOffset <span style="color:#f92672">&amp;=</span> <span style="color:#ae81ff">0xFFFFFFFFF</span>;
</span></span><span style="display:flex;"><span>			DataOffset <span style="color:#f92672">&lt;&lt;=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// In their actual code, this uses an address in the stack to perform their calculation against.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			EAC<span style="color:#f92672">::</span>EacData<span style="color:#f92672">*</span> Data <span style="color:#f92672">=</span> ( EAC<span style="color:#f92672">::</span>EacData<span style="color:#f92672">*</span> )( ( <span style="color:#ae81ff">0xFFFFull</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">48</span> ) <span style="color:#f92672">+</span> DataOffset );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// Nothing complicated here, just gets the current process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			PEPROCESS CurrentProcess <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>( PEPROCESS<span style="color:#f92672">*</span> )( UINT64( KeGetCurrentThread( ) ) <span style="color:#f92672">+</span> EAC<span style="color:#f92672">::</span>ProcessOffset );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// This isn&#39;t exactly what&#39;s done here, I&#39;ve simplified it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> ( CurrentProcess <span style="color:#f92672">!=</span> Data<span style="color:#f92672">-&gt;</span>Process )
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> ( AttemptedCr3 <span style="color:#f92672">!=</span> Data<span style="color:#f92672">-&gt;</span>Cr3 )
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					InterlockedIncrement( Data<span style="color:#f92672">-&gt;</span>Counter );
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>				__writecr3( __readcr3( ) );
</span></span><span style="display:flex;"><span>				Context<span style="color:#f92672">-&gt;</span>Rip <span style="color:#f92672">+=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				InterlockedIncrement( Data<span style="color:#f92672">-&gt;</span>Counter );
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> ( Context<span style="color:#f92672">-&gt;</span>Rip <span style="color:#f92672">&gt;=</span> EAC<span style="color:#f92672">::</span>WhitelistStart <span style="color:#f92672">&amp;&amp;</span> Context<span style="color:#f92672">-&gt;</span>Rip <span style="color:#f92672">&lt;</span> EAC<span style="color:#f92672">::</span>WhitelistEnd )
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#75715e">// This removes the reserved bits, and fixes the CR3.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#75715e">// The decryption changes per update, so don&#39;t expect this to remain.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				UINT64 FixedCr3 <span style="color:#f92672">=</span> AttemptedCr3 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xBFFF000000000FFF</span>;	
</span></span><span style="display:flex;"><span>				FixedCr3 <span style="color:#f92672">|=</span> GetFixedCr3( Data<span style="color:#f92672">-&gt;</span>Key );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				__writecr3( FixedCr3 );
</span></span><span style="display:flex;"><span>				Context<span style="color:#f92672">-&gt;</span>Rip <span style="color:#f92672">+=</span> <span style="color:#ae81ff">3</span>;				
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				InterlockedIncrement( Data<span style="color:#f92672">-&gt;</span>Counter );
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>The code that is not relevant to this article has been redacted, and the remaining code has been formatted for improved readability.</p>
</blockquote>
<p>Although I have improved the code&rsquo;s readability by symbolizing and cleaning it, I will still provide a summary of its behavior:</p>
<ul>
<li>Verify that the exception resulted from a <code>mov cr3, ??</code> instruction.</li>
<li>Extract the instruction&rsquo;s operand and convert it to an index beginning from <code>ZERO/RAX</code>.</li>
<li>Retrieve the value of the <code>CR3</code> register from the the context structure.</li>
<li>Compute the address by calculating the offset to the hook&rsquo;s data structure.</li>
<li>Verify that the exception occurred in Rust&rsquo;s process and check the validity of the <code>CR3</code>.</li>
<li>Verify that the exception occurred within a designated region inside <code>ntoskrnl.exe</code>.</li>
<li>If all of the above conditions are met, update <code>CR3</code> and <code>RIP</code> accordingly.</li>
</ul>
<p>Awesome! You know the drill by now, let&rsquo;s confirm our reversal by comparing Rust&rsquo;s process with the structure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> InitialDataOffset <span style="color:#f92672">=</span> readQword( EacBase <span style="color:#f92672">+</span> EacInitialDataOffset );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> DataOffset <span style="color:#f92672">=</span> bAnd( InitialDataOffset, <span style="color:#ae81ff">0xFFFFFFFFF</span> );
</span></span><span style="display:flex;"><span>DataOffset <span style="color:#f92672">=</span> bShl( DataOffset, <span style="color:#ae81ff">12</span> );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> Data <span style="color:#f92672">=</span> bOr( bShl( <span style="color:#ae81ff">0xFFFF</span>, <span style="color:#ae81ff">48</span> ), DataOffset );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( readQword( Data <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xC</span> ) <span style="color:#f92672">==</span> dbk_getPEProcess( RustPid ) ) <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>	print( <span style="color:#e6db74">&#34;Valid Structure&#34;</span> );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	print( <span style="color:#e6db74">&#34;Invalid Structure&#34;</span> );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">--[[
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	Valid Structure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--]]</span>
</span></span></code></pre></div><h1 id="connecting-the-dots-hal-to-the-rescue">Connecting the Dots: Hal to the Rescue!<a href="#connecting-the-dots-hal-to-the-rescue" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Up until now, we have discovered that EasyAntiCheat is somehow able to intercept any exception generated, but we don&rsquo;t know how. So, let&rsquo;s find out!</p>
<p>While there are multiple approaches to this problem, such as recursing and reversing through every function from the interrupt&rsquo;s routine. I opted for a more suitable method, which involved tracking the return stack directly to the function.</p>
<p>To achieve this, I set a software breakpoint, <code>INT3</code>, on their exception dispatcher routine and read the guest&rsquo;s <code>RSP</code> from the <code>VMCS</code>. Then, I walked the stack and checked if the code was within a kernel code section.</p>
<p>After tracing where it led me, I came to the conclusion that EasyAntiCheat was hooking <code>Hal</code> pointers, as the return address led to the return of a call to a <code>Hal</code> callback.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>InternalData <span style="color:#f92672">=</span> HalpTimerGetInternalData( Timer );
</span></span><span style="display:flex;"><span>Rax <span style="color:#f92672">=</span> ( <span style="color:#f92672">*</span>( <span style="color:#66d9ef">__int64</span> ( <span style="color:#66d9ef">__fastcall</span> <span style="color:#f92672">**</span> )( <span style="color:#66d9ef">__int64</span> ) )( Timer <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x70</span> ) )( InternalData );
</span></span></code></pre></div><p>This can be easily verified this by running this script and observing that all pointers point to EasyAntiCheat&rsquo;s <code>Hal</code> dispatcher:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> Timer <span style="color:#f92672">=</span> readPointer( HalpRegisteredTimers );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> Timer <span style="color:#f92672">~=</span> HalpRegisteredTimers <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>      print( string.format( <span style="color:#e6db74">&#34;Timer %X points to Function %X&#34;</span>, Timer, readPointer( Timer <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x70</span> ) ) );
</span></span><span style="display:flex;"><span>      Timer <span style="color:#f92672">=</span> readPointer( Timer );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p><strong>Congratulations on making it this far, that&rsquo;s really impressive!</strong></p>
<p>Now, I have a little brain-teaser for you. Based on the information I&rsquo;ve given you previously, try to figure out how EasyAntiCheat manages its <code>Hal</code> hooks by reversing their dispatcher.</p>
<h1 id="building-the-puzzle-breaking-the-wall">Building the Puzzle: Breaking the Wall<a href="#building-the-puzzle-breaking-the-wall" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>I hope this article has been helpful in showing how anticheats can exploit the kernel to their advantage. However, this is just the beginning, as it&rsquo;s likely that EasyAntiCheat will eventually start hooking syscalls from their driver - Vanguard has been doing it for a while already.</p>
<p>Furthermore, with EasyAntiCheat&rsquo;s full control of context swaps, they can even implement per-thread hooks that are invisible to external threads. Alternatively, they can create hidden code regions that change on a per-thread basis.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This changes per update, it&#39;s very simple to copy.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define DecryptCr3( Cr3 )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// We don&#39;t need to increment it, it&#39;s useless.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UINT64 DataOffset <span style="color:#f92672">=</span> ( InitialDataOffset <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFFFF</span> ) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>UINT64 Data <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>( UINT64<span style="color:#f92672">*</span> )( ( <span style="color:#ae81ff">0xFFFFull</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">48</span> ) <span style="color:#f92672">+</span> DataOffset );
</span></span><span style="display:flex;"><span>DbgPrint( <span style="color:#e6db74">&#34;[Eac] Data -&gt; %llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, Data );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PEPROCESS RustProcess;
</span></span><span style="display:flex;"><span>PsLookupProcessByProcessId( RustPid, <span style="color:#f92672">&amp;</span>RustProcess );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>UINT64 FakeCr3 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>( UINT64<span style="color:#f92672">*</span> )( UINT64( RustProcess ) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x28</span> );
</span></span><span style="display:flex;"><span>UINT64 FixedCr3 <span style="color:#f92672">=</span> DecryptCr3( FakeCr3 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xBFFF000000000FFF</span> );
</span></span><span style="display:flex;"><span>DbgPrint( <span style="color:#e6db74">&#34;[Eac] FixedCr3 -&gt; %llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, FixedCr3 );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// We don&#39;t want to leak any memory.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ObDereferenceObject( RustProcess );
</span></span></code></pre></div>
      </div></div>

  
    
  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2023 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
